summary(trips$passenger_count)
summary(trips$trip_time_in_secs)
# Check if trip_time_in_secs matches difference
trips <- mutate(trips, trip_time_in_secs_2 = as.duration(dropoff_datetime - pickup_datetime))
all(trips$trip_time_in_secs == as.integer(trips$trip_time_in_secs_2))
# Check difference in measures
trips <- mutate(trips, diff = abs(dseconds(trip_time_in_secs) - trip_time_in_secs_2))
trips <- arrange(trips, desc(diff))
head(trips$diff, 20)
# Filter to only have trips that differ in these two variables by less than 1 min
trips <- filter(trips, diff < dminutes(1))
head(trips$diff, 20)
range(trips$diff) #difference ranging from 0 to 57 seconds!
# Drop irrelevant columns
trips <- select(trips, -trip_time_in_secs_2, -diff)
summary(trips$trip_time_in_secs)
# Filter to remove negative trip times that are less than 60 seconds (1 min)
trips <- trips %>%
filter(trip_time_in_secs >= 60 )
summary(trips$trip_time_in_secs)
# Add average speed
trips <- mutate(trips, avg_speed = trip_distance/(trip_time_in_secs/3600))
# Top average speeds
head(sort(trips$avg_speed, decreasing = T))
# Filter out trip speeds greater than 100mph
trips <- filter(trips, avg_speed < 100)
summary(trips$avg_speed)
# Check number of unrealistic longitude and latitude values
nrow(trips[trips$pickup_longitude < -90 | trips$pickup_longitude > 90, ])
nrow(trips[trips$dropoff_longitude < -90 | trips$dropoff_longitude > 90, ])
nrow(trips[trips$pickup_latitude < -180 | trips$pickup_latitude > 180, ])
nrow(trips[trips$dropoff_latitude < -180 | trips$dropoff_latitude > 180, ])
# Filter out unrealistic coordinates
trips <- filter(trips,
pickup_longitude >= -90 & pickup_longitude <= 90,
dropoff_longitude >= -90 & dropoff_longitude <= 90,
pickup_latitude >= -180 & pickup_latitude <= 180,
dropoff_latitude >= -180 & dropoff_latitude <=180)
# Compute straight-line distances in miles
# trips <- mutate(trips,
#                 straight_dist = distm(x = cbind(pickup_longitude, pickup_latitude),
#                                       y = cbind(dropoff_longitude, dropoff_latitude),
#                                       fun = distHaversine))
# Examine the different values for payment type
unique(fares$payment_type)
# Filter only on cash (CSH) and and credit (CRD) payment types
fares <- fares %>%
filter(payment_type %in% c("CSH", "CRD"))
unique(fares$payment_type)
# Summary on fare_amount
summary(fares$fare_amount)
# Examining outliers, negative values, and values greater than 500
nrow(fares[fares$fare_amount < 0, ])
sum(fares$total_amount[fares$fare_amount < 0] < 0)
fares$fare_amount[fares$fare_amount > 500]
# Filter for fare amounts greater than 2.50
fares <- fares %>%
filter(fare_amount >= 2.50)
# Reobserving fare_amount
summary(fares$fare_amount)
summary(fares$surcharge)
summary(fares$mta_tax)
summary(fares$tip_amount)
summary(fares$tolls_amount)
summary(fares$total_amount)
# Check that total_amount is true total
fares <- mutate(fares, calc_total =
fare_amount + surcharge + mta_tax + tip_amount + tolls_amount)
all(fares$total_amount == fares$calc_total)
fares <- mutate(fares, diff = round(abs(total_amount - calc_total), 3))
# Remove differences larger than $1
head(sort(fares$diff, decreasing = T))
nrow(fares[fares$diff > 0, ])
fares <- filter(fares, diff == 0)
summary(fares$diff)
# Remove extra variables
fares <- select(fares, -calc_total, -diff)
trips$UID <- paste(trips$medallion, trips$hack_license, trips$pickup_datetime, sep = "_")
fares$UID <- paste(fares$medallion, fares$hack_license, fares$pickup_datetime, sep = "_")
trips %>% count(UID)%>%filter(n>1) #works for trips
length(unique(trips$UID)) == nrow(trips) #also see if true
fares %>% count(UID)%>%filter(n>1) #does not work for fares
length(unique(fares$UID)) == nrow(fares) #we can see that there are duplicates!
trips <- distinct(trips)
fares <- distinct(fares)
fares$pickup_datetime <- as.POSIXct(fares$pickup_datetime)
taxi_data <- trips %>% left_join(fares)
taxi_data %>% count(UID)%>%filter(n>1) #works for trips
# let's use anti join to see if there are rows in trips that don't have corresponding fares associated
trips %>% anti_join(fares)
# now let's get rid of those "duplicate" rows in the fares tibble by keeping the fare with highest total amount
fares <- fares %>% arrange(desc(total_amount)) %>% distinct(medallion, hack_license, pickup_datetime, .keep_all = TRUE)
taxi_data <- inner_join(trips,fares)
nrow(taxi_data) + nrow(trips %>% anti_join(fares)) == nrow(trips) # we now see that the number of rows resulting from the inner joing plus the nrow  from the anti join does equal the nrow of trips
length(unique(taxi_data$UID)) == nrow(taxi_data) #one row for each trip test
sum(is.na(taxi_data[,16:22])) #complete fare information for each trip test.
QE <- taxi_data %>%
group_by(medallion)%>%
transmute(total_trips = n(), total_passengers = sum(passenger_count), total_time_with_passengers = sum(trip_time_in_secs), total_distance = sum(trip_distance), total_earnings = sum(total_amount))
head(QE)
taxi_data$hour <- hour(taxi_data$pickup_datetime)#get hours as its own column
length(unique(taxi_data$hour)) #check to see if there are 24 unique hours!
options(scipen = 999)
Combinations<-crossing(taxi_data$hack_license,taxi_data$hour)
names(Combinations) <- c("hack_license", "hour")
taxi_data <- right_join(taxi_data,Combinations)
QF <- taxi_data %>%
group_by(hack_license,hour) %>%
mutate(passenger_count = ifelse(is.na(passenger_count), 0, passenger_count), trip =  ifelse(!is.na(medallion), TRUE, FALSE)) %>%
summarise(total_passengers_picked_up = sum(passenger_count), trips_started = sum(trip))
head(QF, 24)
# Check latest dropoff dates and times
taxi_data %>% arrange(desc(dropoff_datetime)) %>% select(dropoff_datetime) %>% head(10)
# Sample of 100 to test on
sample_taxi <- filter(taxi_data, hack_license %in% sample(taxi_data$hack_license, 100))
# Five Cases
# 1. trip starts and ends in same hour
# To ID: hour == hour_end
# time = time in secs; miles = trip dist; earnings = fare + tip
# 2. trip starts this hour, but ends in different hour same day
# To ID: hour < hour_end
# time = (hour + 1) - start time; miles = avg_spd * (time/3600);
# earnings = (fare + tip) * (time/trip time)
# 3. >special case: starts this hour and ends hour 0 of next day
# To ID: hour > hour_end
# time = (hour + 1) - start time; miles = avg_spd * (time/3600);
# earnings = (fare + tip) * (time/trip time)
# 4. trip started in previous hour and ends this hour
# To ID: if hour(dropoff) for previous hour == current hour, then
# time = dropoff - (hour-1); miles = avg_spd * (time/3600);
# earnings = (fare + tip) * (time/trip time)
# 5. trip started in some previous hour and ends in some future hour, and includes this hour
# To ID:
# time = 3600; miles = avg_speed; earnings = (fare + tip) * (3600/trip time)
QG <- sample_taxi %>%
# Subset to only needed columns
select(hack_license, pickup_datetime, dropoff_datetime, trip_time_in_secs,
trip_distance, avg_speed, fare_amount, tip_amount, hour) %>%
# Add end time column
mutate(end_hour =
case_when(date(dropoff_datetime) == "2013-08-15" ~ hour(dropoff_datetime),
date(dropoff_datetime) == "2013-08-16" ~ as.integer(24))) %>%
# Apply to observations without NAs for end_hour
QG <- QG %>%  group_by(hack_license, hour) %>%
mutate(total_time_with_passengers =
case_when(hour == end_hour ~ as.numeric(trip_time_in_secs),
hour < end_hour ~ as.numeric(as.duration(update(pickup_datetime,
hour = (hour + 1), minute = 0, second = 0) - pickup_datetime)),
end_hour == NA ~ 0),
miles_with_passengers =
case_when(hour == end_hour ~ as.numeric(trip_distance),
hour < end_hour ~
as.numeric(avg_speed * (total_time_with_passengers/3600)),
end_hour == NA ~ 0),
earnings =
case_when(hour == end_hour ~ as.numeric(sum(fare_amount, tip_amount)),
hour < end_hour ~ as.numeric((fare_amount + tip_amount) *
(total_time_with_passengers/trip_time_in_secs)),
end_hour == NA ~ 0))
QG <- sample_taxi %>%
# Subset to only needed columns
select(hack_license, pickup_datetime, dropoff_datetime, trip_time_in_secs,
trip_distance, avg_speed, fare_amount, tip_amount, hour) %>%
# Add end time column
mutate(end_hour =
case_when(date(dropoff_datetime) == "2013-08-15" ~ hour(dropoff_datetime),
date(dropoff_datetime) == "2013-08-16" ~ as.integer(24))) %>%
# Apply to observations without NAs for end_hour
QG <- QG %>%  group_by(hack_license, hour) %>%
mutate(total_time_with_passengers =
case_when(hour == end_hour ~ as.numeric(trip_time_in_secs),
hour < end_hour ~ as.numeric(as.duration(update(pickup_datetime,
hour = (hour + 1), minute = 0, second = 0) - pickup_datetime)),
end_hour == NA ~ 0),
miles_with_passengers =
case_when(hour == end_hour ~ as.numeric(trip_distance),
hour < end_hour ~
as.numeric(avg_speed * (total_time_with_passengers/3600)),
end_hour == NA ~ 0),
earnings =
case_when(hour == end_hour ~ as.numeric(sum(fare_amount, tip_amount)),
hour < end_hour ~ as.numeric((fare_amount + tip_amount) *
(total_time_with_passengers/trip_time_in_secs)),
end_hour == NA ~ 0))
QG <- sample_taxi %>%
# Subset to only needed columns
select(hack_license, pickup_datetime, dropoff_datetime, trip_time_in_secs,
trip_distance, avg_speed, fare_amount, tip_amount, hour) %>%
# Add end time column
mutate(end_hour =
case_when(date(dropoff_datetime) == "2013-08-15" ~ hour(dropoff_datetime),
date(dropoff_datetime) == "2013-08-16" ~ as.integer(24)))
QG <- QG %>%  group_by(hack_license, hour) %>%
mutate(total_time_with_passengers =
case_when(hour == end_hour ~ as.numeric(trip_time_in_secs),
hour < end_hour ~ as.numeric(as.duration(update(pickup_datetime,
hour = (hour + 1), minute = 0, second = 0) - pickup_datetime)),
end_hour == NA ~ 0),
miles_with_passengers =
case_when(hour == end_hour ~ as.numeric(trip_distance),
hour < end_hour ~
as.numeric(avg_speed * (total_time_with_passengers/3600)),
end_hour == NA ~ 0),
earnings =
case_when(hour == end_hour ~ as.numeric(sum(fare_amount, tip_amount)),
hour < end_hour ~ as.numeric((fare_amount + tip_amount) *
(total_time_with_passengers/trip_time_in_secs)),
end_hour == NA ~ 0))
taxi_data$hourrange <- paste(hour(taxi_data$pickup_datetime), hour(taxi_data$dropoff_datetime), sep = "-")
taxi_data$differencetime = difftime(taxi_data$dropoff_datetime,taxi_data$pickup_datetime)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(geosphere)
#read in csvs
trips <- read_csv("../../data/trips_hw_1.csv")
#read in csvs
trips <- read_csv("../../data/trips_hw_1.csv")
#read in csvs
trips <- read_csv("../../trips_hw_1.csv")
#read in csvs
trips <- read_csv("../../trips_hw_1.csv")
#read in csvs
trips <- read_csv("trips_hw_1.csv")
fares <- read_csv("fares_hw_1.csv")
summary(trips$trip_distance)
# Check trips over 50 miles
nrow(trips[trips$trip_distance > 50, ])
# Filter between 0 and 50 miles
trips <- trips %>%
filter(trip_distance > 0 & trip_distance < 50) %>%
arrange(trip_distance)
summary(trips$trip_distance)
summary(trips$passenger_count)
# Filter out 0 counts
trips <- trips %>%
filter(passenger_count > 0)
# New summary
summary(trips$passenger_count)
summary(trips$trip_time_in_secs)
# Check if trip_time_in_secs matches difference
trips <- mutate(trips, trip_time_in_secs_2 = as.duration(dropoff_datetime - pickup_datetime))
all(trips$trip_time_in_secs == as.integer(trips$trip_time_in_secs_2))
# Check difference in measures
trips <- mutate(trips, diff = abs(dseconds(trip_time_in_secs) - trip_time_in_secs_2))
trips <- arrange(trips, desc(diff))
head(trips$diff, 20)
# Filter to only have trips that differ in these two variables by less than 1 min
trips <- filter(trips, diff < dminutes(1))
head(trips$diff, 20)
range(trips$diff) #difference ranging from 0 to 57 seconds!
# Drop irrelevant columns
trips <- select(trips, -trip_time_in_secs_2, -diff)
summary(trips$trip_time_in_secs)
# Filter to remove negative trip times that are less than 60 seconds (1 min)
trips <- trips %>%
filter(trip_time_in_secs >= 60 )
summary(trips$trip_time_in_secs)
# Add average speed
trips <- mutate(trips, avg_speed = trip_distance/(trip_time_in_secs/3600))
# Top average speeds
head(sort(trips$avg_speed, decreasing = T))
# Filter out trip speeds greater than 100mph
trips <- filter(trips, avg_speed < 100)
summary(trips$avg_speed)
# Check number of unrealistic longitude and latitude values
nrow(trips[trips$pickup_longitude < -90 | trips$pickup_longitude > 90, ])
nrow(trips[trips$dropoff_longitude < -90 | trips$dropoff_longitude > 90, ])
nrow(trips[trips$pickup_latitude < -180 | trips$pickup_latitude > 180, ])
nrow(trips[trips$dropoff_latitude < -180 | trips$dropoff_latitude > 180, ])
# Filter out unrealistic coordinates
trips <- filter(trips,
pickup_longitude >= -90 & pickup_longitude <= 90,
dropoff_longitude >= -90 & dropoff_longitude <= 90,
pickup_latitude >= -180 & pickup_latitude <= 180,
dropoff_latitude >= -180 & dropoff_latitude <=180)
# Examine the different values for payment type
unique(fares$payment_type)
# Filter only on cash (CSH) and and credit (CRD) payment types
fares <- fares %>%
filter(payment_type %in% c("CSH", "CRD"))
unique(fares$payment_type)
# Summary on fare_amount
summary(fares$fare_amount)
# Examining outliers, negative values, and values greater than 500
nrow(fares[fares$fare_amount < 0, ])
sum(fares$total_amount[fares$fare_amount < 0] < 0)
fares$fare_amount[fares$fare_amount > 500]
# Filter for fare amounts greater than 2.50
fares <- fares %>%
filter(fare_amount >= 2.50)
# Reobserving fare_amount
summary(fares$fare_amount)
summary(fares$surcharge)
summary(fares$mta_tax)
summary(fares$tip_amount)
summary(fares$tolls_amount)
summary(fares$total_amount)
# Check that total_amount is true total
fares <- mutate(fares, calc_total =
fare_amount + surcharge + mta_tax + tip_amount + tolls_amount)
all(fares$total_amount == fares$calc_total)
fares <- mutate(fares, diff = round(abs(total_amount - calc_total), 3))
# Remove differences larger than $1
head(sort(fares$diff, decreasing = T))
nrow(fares[fares$diff > 0, ])
fares <- filter(fares, diff == 0)
summary(fares$diff)
# Remove extra variables
fares <- select(fares, -calc_total, -diff)
trips$UID <- paste(trips$medallion, trips$hack_license, trips$pickup_datetime, sep = "_")
fares$UID <- paste(fares$medallion, fares$hack_license, fares$pickup_datetime, sep = "_")
trips %>% count(UID)%>%filter(n>1) #works for trips
length(unique(trips$UID)) == nrow(trips) #also see if true
fares %>% count(UID)%>%filter(n>1) #does not work for fares
length(unique(fares$UID)) == nrow(fares) #we can see that there are duplicates!
trips <- distinct(trips)
fares <- distinct(fares)
fares$pickup_datetime <- as.POSIXct(fares$pickup_datetime)
taxi_data <- trips %>% left_join(fares)
taxi_data %>% count(UID)%>%filter(n>1) #works for trips
# let's use anti join to see if there are rows in trips that don't have corresponding fares associated
trips %>% anti_join(fares)
# now let's get rid of those "duplicate" rows in the fares tibble by keeping the fare with highest total amount
fares <- fares %>% arrange(desc(total_amount)) %>% distinct(medallion, hack_license, pickup_datetime, .keep_all = TRUE)
taxi_data <- inner_join(trips,fares)
nrow(taxi_data) + nrow(trips %>% anti_join(fares)) == nrow(trips) # we now see that the number of rows resulting from the inner joing plus the nrow  from the anti join does equal the nrow of trips
length(unique(taxi_data$UID)) == nrow(taxi_data) #one row for each trip test
sum(is.na(taxi_data[,16:22])) #complete fare information for each trip test.
QE <- taxi_data %>%
group_by(medallion)%>%
transmute(total_trips = n(), total_passengers = sum(passenger_count), total_time_with_passengers = sum(trip_time_in_secs), total_distance = sum(trip_distance), total_earnings = sum(total_amount))
head(QE)
QF <- taxi_data
QF$hour <- hour(QF$pickup_datetime)#get hours as its own column
length(unique(QF$hour)) #check to see if there are 24 unique hours!
options(scipen = 999)
Combinations<-crossing(QF$hack_license,QF$hour)
names(Combinations) <- c("hack_license", "hour")
QF <- taxi_data %>% right_join(Combinations) %>%
group_by(hack_license,hour) %>%
mutate(passenger_count = ifelse(is.na(passenger_count), 0, passenger_count), trip =  ifelse(!is.na(medallion), TRUE, FALSE)) %>%
summarise(total_passengers_picked_up = sum(passenger_count), trips_started = sum(trip))
head(QF, 24)
QF <- taxi_data
QF$hour <- hour(QF$pickup_datetime)#get hours as its own column
length(unique(QF$hour)) #check to see if there are 24 unique hours!
options(scipen = 999)
Combinations<-crossing(QF$hack_license,QF$hour)
names(Combinations) <- c("hack_license", "hour")
QF <- right_join(QF, Combinations)
QF <-QF %>%
group_by(hack_license,hour) %>%
mutate(passenger_count = ifelse(is.na(passenger_count), 0, passenger_count), trip =  ifelse(!is.na(medallion), TRUE, FALSE)) %>%
summarise(total_passengers_picked_up = sum(passenger_count), trips_started = sum(trip))
head(QF, 24)
QG <- taxi_data
QG$pickuphour <- hour(QG$pickup_datetime)
QG$dropoffhour <- hour(QG$dropoff_datetime)
# QG <-QG %>%
#   mutate(dropoffhour =
#            case_when(date(dropoff_datetime) == "2013-08-15" ~ hour(dropoff_datetime),
#                      date(dropoff_datetime) == "2013-08-16" ~ as.integer(24)))
hour <- 0:23
QG <- crossing(QG, hour)
nrow(QG) == 24*nrow(taxi_data) #if the taxi_data table had n rows, then the new table has 24n rows, where each row is a trip-hour
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(geosphere)
trips <- read_csv("trip_data_8.csv")
#read in csvs
trips <- read_csv("trips_hw_1.csv")
fares <- read_csv("fares_hw_1.csv")
summary(trips$trip_distance)
# Check trips over 50 miles
nrow(trips[trips$trip_distance > 50, ])
# Filter between 0 and 50 miles
trips <- trips %>%
filter(trip_distance > 0 & trip_distance < 50) %>%
arrange(trip_distance)
summary(trips$trip_distance)
summary(trips$passenger_count)
# Filter out 0 counts
trips <- trips %>%
filter(passenger_count > 0)
# New summary
summary(trips$passenger_count)
summary(trips$trip_time_in_secs)
# Check if trip_time_in_secs matches difference
trips <- mutate(trips, trip_time_in_secs_2 = as.duration(dropoff_datetime - pickup_datetime))
all(trips$trip_time_in_secs == as.integer(trips$trip_time_in_secs_2))
# Check difference in measures
trips <- mutate(trips, diff = abs(dseconds(trip_time_in_secs) - trip_time_in_secs_2))
trips <- arrange(trips, desc(diff))
head(trips$diff, 20)
# Filter to only have trips that differ in these two variables by less than 1 min
trips <- filter(trips, diff < dminutes(1))
head(trips$diff, 20)
range(trips$diff) #difference ranging from 0 to 57 seconds!
# Drop irrelevant columns
trips <- select(trips, -trip_time_in_secs_2, -diff)
summary(trips$trip_time_in_secs)
# Filter to remove negative trip times that are less than 60 seconds (1 min)
trips <- trips %>%
filter(trip_time_in_secs >= 60 )
summary(trips$trip_time_in_secs)
# Add average speed
trips <- mutate(trips, avg_speed = trip_distance/(trip_time_in_secs/3600))
# Top average speeds
head(sort(trips$avg_speed, decreasing = T))
# Filter out trip speeds greater than 100mph
trips <- filter(trips, avg_speed < 100)
summary(trips$avg_speed)
# Check number of unrealistic longitude and latitude values
nrow(trips[trips$pickup_longitude < -90 | trips$pickup_longitude > 90, ])
nrow(trips[trips$dropoff_longitude < -90 | trips$dropoff_longitude > 90, ])
nrow(trips[trips$pickup_latitude < -180 | trips$pickup_latitude > 180, ])
nrow(trips[trips$dropoff_latitude < -180 | trips$dropoff_latitude > 180, ])
# Filter out unrealistic coordinates
trips <- filter(trips,
pickup_longitude >= -90 & pickup_longitude <= 90,
dropoff_longitude >= -90 & dropoff_longitude <= 90,
pickup_latitude >= -180 & pickup_latitude <= 180,
dropoff_latitude >= -180 & dropoff_latitude <=180)
# Compute straight-line distances in miles
# trips <- mutate(trips,
#                 straight_dist = distm(x = cbind(pickup_longitude, pickup_latitude),
#                                       y = cbind(dropoff_longitude, dropoff_latitude),
#                                       fun = distHaversine))
# Examine the different values for payment type
unique(fares$payment_type)
# Filter only on cash (CSH) and and credit (CRD) payment types
fares <- fares %>%
filter(payment_type %in% c("CSH", "CRD"))
unique(fares$payment_type)
# Summary on fare_amount
summary(fares$fare_amount)
# Examining outliers, negative values, and values greater than 500
nrow(fares[fares$fare_amount < 0, ])
sum(fares$total_amount[fares$fare_amount < 0] < 0)
fares$fare_amount[fares$fare_amount > 500]
# Filter for fare amounts greater than 2.50
fares <- fares %>%
filter(fare_amount >= 2.50)
# Reobserving fare_amount
summary(fares$fare_amount)
summary(fares$surcharge)
summary(fares$mta_tax)
summary(fares$tip_amount)
summary(fares$tolls_amount)
summary(fares$total_amount)
# Check that total_amount is true total
fares <- mutate(fares, calc_total =
fare_amount + surcharge + mta_tax + tip_amount + tolls_amount)
all(fares$total_amount == fares$calc_total)
fares <- mutate(fares, diff = round(abs(total_amount - calc_total), 3))
# Remove differences larger than $1
head(sort(fares$diff, decreasing = T))
nrow(fares[fares$diff > 0, ])
fares <- filter(fares, diff == 0)
summary(fares$diff)
# Remove extra variables
fares <- select(fares, -calc_total, -diff)
trips$UID <- paste(trips$medallion, trips$hack_license, trips$pickup_datetime, sep = "_")
fares$UID <- paste(fares$medallion, fares$hack_license, fares$pickup_datetime, sep = "_")
trips %>% count(UID)%>%filter(n>1) #works for trips
length(unique(trips$UID)) == nrow(trips) #also see if true
fares %>% count(UID)%>%filter(n>1) #does not work for fares
length(unique(fares$UID)) == nrow(fares) #we can see that there are duplicates!
trips <- distinct(trips)
fares <- distinct(fares)
fares$pickup_datetime <- as.POSIXct(fares$pickup_datetime)
taxi_data <- trips %>% left_join(fares)
taxi_data %>% count(UID)%>%filter(n>1) #works for trips
# let's use anti join to see if there are rows in trips that don't have corresponding fares associated
trips %>% anti_join(fares)
# now let's get rid of those "duplicate" rows in the fares tibble by keeping the fare with highest total amount
fares <- fares %>% arrange(desc(total_amount)) %>% distinct(medallion, hack_license, pickup_datetime, .keep_all = TRUE)
taxi_data <- inner_join(trips,fares)
nrow(taxi_data) + nrow(trips %>% anti_join(fares)) == nrow(trips) # we now see that the number of rows resulting from the inner joing plus the nrow  from the anti join does equal the nrow of trips
length(unique(taxi_data$UID)) == nrow(taxi_data) #one row for each trip test
sum(is.na(taxi_data[,16:22])) #complete fare information for each trip test.
QE <- taxi_data %>%
group_by(medallion)%>%
transmute(total_trips = n(), total_passengers = sum(passenger_count), total_time_with_passengers = sum(trip_time_in_secs), total_distance = sum(trip_distance), total_earnings = sum(total_amount))
head(QE)
QF <- taxi_data
QF$hour <- hour(QF$pickup_datetime)#get hours as its own column
length(unique(QF$hour)) #check to see if there are 24 unique hours!
options(scipen = 999)
Combinations<-crossing(QF$hack_license,QF$hour)
names(Combinations) <- c("hack_license", "hour")
QF <- right_join(QF, Combinations)
QF <- QF %>%
group_by(hack_license,hour) %>%
mutate(passenger_count = ifelse(is.na(passenger_count), 0, passenger_count), trip =  ifelse(!is.na(medallion), TRUE, FALSE)) %>%
summarise(total_passengers_picked_up = sum(passenger_count), trips_started = sum(trip))
head(QF, 24)
View(taxi_data)
seconds(3600)
<-seconds(3600)
x<-seconds(3600)
str(x)
x <- as.duration(3600)
str(x)
x
y <- as.duration(0)
0
y
2013-08-16
?update
